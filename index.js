const { Telegraf } = require("telegraf");
const express = require('express');
const fs = require('fs').promises;
const path = require('path');

const telegramToken = process.env.TELEGRAM_TOKEN;
const bot = new Telegraf(telegramToken);
const app = express();
const PORT = process.env.PORT || 3000;

let isBotActive = false;
let memory = {
    words: new Set(),
    phrases: new Set(),
    photos: []
};
let recentMessages = [];
let lastActivityTime = Date.now();
let photoTimer = null;
const memoryFile = path.join(__dirname, 'memory.json');

// üî• –ó–∞–≥—Ä—É–∑–∫–∞ –ø–∞–º—è—Ç–∏
async function loadMemory() {
    try {
        const data = await fs.readFile(memoryFile, 'utf8');
        const saved = JSON.parse(data);
        memory.words = new Set(saved.words || []);
        memory.phrases = new Set(saved.phrases || []);
        memory.photos = saved.photos || [];
        console.log("üß† –ü–∞–º—è—Ç—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞!");
    } catch (error) {
        memory = {
            words: new Set(),
            phrases: new Set(),
            photos: [] // –£–±—Ä–∞–ª–∏ –Ω–µ—Ä–∞–±–æ—Ç–∞—é—â–∏–µ —Ñ–æ—Ç–æ
        };
        console.log("üß† –ù–æ–≤–∞—è –ø–∞–º—è—Ç—å —Å–æ–∑–¥–∞–Ω–∞");
    }
}

async function saveMemory() {
    try {
        const toSave = {
            words: Array.from(memory.words),
            phrases: Array.from(memory.phrases),
            photos: memory.photos
        };
        await fs.writeFile(memoryFile, JSON.stringify(toSave, null, 2));
    } catch (error) {
        console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–∞–º—è—Ç–∏:", error);
    }
}

// üî• –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏ —Ñ–æ—Ç–æ URL
function isValidPhotoUrl(url) {
    try {
        const parsed = new URL(url);
        return parsed.protocol === 'https:' && 
               /\.(jpg|jpeg|png|gif)$/i.test(parsed.pathname);
    } catch {
        return false;
    }
}

// üî• –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ñ–æ—Ç–æ –ø–æ URL
function addPhotoFromUrl(url) {
    if (isValidPhotoUrl(url) && !memory.photos.includes(url)) {
        memory.photos.push(url);
        saveMemory();
        return true;
    }
    return false;
}

// üî• –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ñ–æ—Ç–æ –∏–∑ —Å–æ–æ–±—â–µ–Ω–∏—è
async function savePhotoFromMessage(ctx) {
    try {
        const photo = ctx.message.photo[ctx.message.photo.length - 1];
        const fileLink = await bot.telegram.getFileLink(photo.file_id);
        const photoUrl = fileLink.href;
        
        if (!memory.photos.includes(photoUrl)) {
            memory.photos.push(photoUrl);
            saveMemory();
            return photoUrl;
        }
        return null;
    } catch (error) {
        console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–æ—Ç–æ:", error);
        return null;
    }
}

// üî• –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–æ—Ç–æ
async function sendRandomPhoto(ctx) {
    if (memory.photos.length === 0) {
        await ctx.reply("–í –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –Ω–µ—Ç —Ñ–æ—Ç–æ! üì∏");
        return;
    }

    try {
        // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –≤–∞–ª–∏–¥–Ω—ã–µ —Ñ–æ—Ç–æ
        const validPhotos = memory.photos.filter(photo => isValidPhotoUrl(photo));
        
        if (validPhotos.length === 0) {
            await ctx.reply("–ù–µ—Ç —Ä–∞–±–æ—á–∏—Ö —Ñ–æ—Ç–æ –≤ –∫–æ–ª–ª–µ–∫—Ü–∏–∏! ‚ùå");
            return;
        }

        const randomPhoto = validPhotos[Math.floor(Math.random() * validPhotos.length)];
        await ctx.replyWithPhoto(randomPhoto, {
            caption: "–î–µ—Ä–∂–∏—Ç–µ —Ñ–æ—Ç–∫—É! üì∏"
        });
    } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–æ—Ç–æ:", error);
        await ctx.reply("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–æ—Ç–æ üòî");
    }
}

// üî• –ê–Ω–∞–ª–∏–∑ —Å–æ–æ–±—â–µ–Ω–∏–π
function analyzeMessage(text) {
    const words = text.toLowerCase().split(/\s+/).filter(word => word.length > 2);
    const phrases = text.split(/[.!?]/).filter(phrase => phrase.trim().length > 3);
    
    words.forEach(word => memory.words.add(word));
    phrases.forEach(phrase => memory.phrases.add(phrase.trim()));
    
    recentMessages.push(text);
    if (recentMessages.length > 20) {
        recentMessages.shift();
    }
    
    lastActivityTime = Date.now();
}

// üî• –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Ñ—Ä–∞–∑
function generateMixedPhrase() {
    if (recentMessages.length < 3) return null;
    
    try {
        const availableWords = Array.from(memory.words).filter(word => word.length > 2);
        if (availableWords.length < 5) return null;
        
        const wordCount = 3 + Math.floor(Math.random() * 4);
        let newPhrase = [];
        
        for (let i = 0; i < wordCount; i++) {
            const randomWord = availableWords[Math.floor(Math.random() * availableWords.length)];
            newPhrase.push(randomWord);
        }
        
        let result = newPhrase.join(' ');
        result = result.charAt(0).toUpperCase() + result.slice(1);
        
        const endings = ['.', '!', '?', '...'];
        result += endings[Math.floor(Math.random() * endings.length)];
        
        return result;
    } catch (error) {
        return null;
    }
}

// üî• –¢–∞–π–º–µ—Ä—ã
function startTimers(ctx) {
    if (photoTimer) clearInterval(photoTimer);
    
    setInterval(async () => {
        if (isBotActive && Date.now() - lastActivityTime < 300000) {
            const mixedPhrase = generateMixedPhrase();
            if (mixedPhrase && Math.random() > 0.6) {
                await ctx.reply(mixedPhrase);
            }
        }
    }, 180000);
    
    photoTimer = setInterval(async () => {
        if (isBotActive && Date.now() - lastActivityTime < 3600000) {
            if (Math.random() > 0.5) {
                await sendRandomPhoto(ctx);
            }
        }
    }, 180000 + Math.floor(Math.random() * 3420000));
}

// –§—Ä–∞–∑—ã –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è/–≤—ã–∫–ª—é—á–µ–Ω–∏—è
const wakeUpPhrases = ["–ì—É–¥–µ–Ω—Ç–∞–∫! üòé –í–∏—Ç–∞–ª—è –Ω–∞ —Å–≤—è–∑–∏!", "–í–∏—Ç–∞–ª—è –≤ –∑–¥–∞–Ω–∏–∏! üí™", "–ü—Ä–æ—Å–Ω—É–ª—Å—è! üöÄ –ì–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!"];
const sleepPhrases = ["–ê–π –º–ª—è! –ú–∞—Å–ª–∏–Ω—É –ø–æ–π–º–∞–ª! üòµ‚Äçüí´", "–í–∏—Ç–∞–ª—è —É—Ö–æ–¥–∏—Ç –≤ –∑–∞–∫–∞—Ç! üåÖ", "–û—Ç–∫–ª—é—á–∞—é—Å—å! üîå"];

bot.on("text", async (ctx) => {
    const messageText = ctx.message.text;
    const lowerText = messageText.toLowerCase();
    
    analyzeMessage(messageText);
    
    // –ö–æ–º–∞–Ω–¥–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ñ–æ—Ç–æ –ø–æ URL
    if (lowerText.startsWith('–¥–æ–±–∞–≤–∏—Ç—å —Ñ–æ—Ç–æ ') && isBotActive) {
        const photoUrl = messageText.slice(13).trim();
        if (addPhotoFromUrl(photoUrl)) {
            await ctx.reply("–§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –∫–æ–ª–ª–µ–∫—Ü–∏—é! üì∏");
        } else {
            await ctx.reply("–ù–µ–≤–µ—Ä–Ω–∞—è —Å—Å—ã–ª–∫–∞ –Ω–∞ —Ñ–æ—Ç–æ! ‚ùå");
        }
        return;
    }
    
    // –ö–æ–º–∞–Ω–¥–∞ –ø–æ–∫–∞–∑–∞ –≤—Å–µ—Ö —Ñ–æ—Ç–æ
    if (lowerText === '–º–æ–∏ —Ñ–æ—Ç–æ' && isBotActive) {
        await ctx.reply(`–í –º–æ–µ–π –∫–æ–ª–ª–µ–∫—Ü–∏–∏ ${memory.photos.length} —Ñ–æ—Ç–æ! üñºÔ∏è`);
        return;
    }
    
    // üî• –ö–û–ú–ê–ù–î–ê UwU
    if ((lowerText === 'uwu' || lowerText === '–≤–∏—Ç–∞–ª—è uwu') && isBotActive) {
        await sendRandomPhoto(ctx);
        return;
    }
    
    // –ö–æ–º–∞–Ω–¥—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    if (lowerText.includes('–≤–∏—Ç–∞–ª—è –ø—Ä–æ—Å–Ω–∏—Å—å') || lowerText.includes('–≤–∏—Ç–∞–ª—è –≤–∫–ª—é—á–∏—Å—å')) {
        if (!isBotActive) {
            isBotActive = true;
            const phrase = wakeUpPhrases[Math.floor(Math.random() * wakeUpPhrases.length)];
            await ctx.reply(phrase);
            startTimers(ctx);
        } else {
            await ctx.reply("–Ø —É–∂–µ –≤ —Å—Ç—Ä–æ—é! üí™");
        }
        return;
    }
    
    if (lowerText.includes('–≤–∏—Ç–∞–ª—è —É–π–¥–∏') || lowerText.includes('–≤–∏—Ç–∞–ª—è –≤—ã—Ä—É–±–∞–π')) {
        if (isBotActive) {
            isBotActive = false;
            const phrase = sleepPhrases[Math.floor(Math.random() * sleepPhrases.length)];
            await ctx.reply(phrase);
            if (photoTimer) clearInterval(photoTimer);
        } else {
            await ctx.reply("–Ø –∏ —Ç–∞–∫ –æ—Ç–¥—ã—Ö–∞—é... üò¥");
        }
        return;
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞
    if (lowerText.includes('–≤–∏—Ç–∞–ª—è —Ç—ã –∑–¥–µ—Å—å') || lowerText.includes('–≤–∏—Ç–∞–ª—è —Å—Ç–∞—Ç—É—Å')) {
        await ctx.reply(isBotActive ? "–ù–∞ –º–µ—Å—Ç–µ! üí™ –ì–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!" : "–°–ø–ª—é... üò¥ –†–∞–∑–±—É–¥–∏ –∫–æ–º–∞–Ω–¥–æ–π '–í–∏—Ç–∞–ª—è –ø—Ä–æ—Å–Ω–∏—Å—å'");
        return;
    }

    // –û—Ç–≤–µ—Ç –Ω–∞ –æ–±—Ä–∞—â–µ–Ω–∏–µ
    if (isBotActive && (lowerText.startsWith('–≤–∏—Ç–∞–ª—è') || Math.random() > 0.7)) {
        const userMessage = lowerText.startsWith('–≤–∏—Ç–∞–ª—è') ? messageText.slice(7).trim() : messageText;
        
        if (userMessage) {
            await ctx.sendChatAction('typing');
            
            const mixedPhrase = generateMixedPhrase();
            const response = mixedPhrase || "–ß—Ç–æ-—Ç–æ —è —Å–µ–≥–æ–¥–Ω—è –Ω–µ –≤ —Ñ–æ—Ä–º–µ... ü§î";
            
            await ctx.reply(response);
        }
    }
});

// üî• –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ç–æ-—Å–æ–æ–±—â–µ–Ω–∏–π
bot.on("photo", async (ctx) => {
    if (isBotActive) {
        const savedUrl = await savePhotoFromMessage(ctx);
        if (savedUrl) {
            await ctx.reply("–§–æ—Ç–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ –º–æ—é –∫–æ–ª–ª–µ–∫—Ü–∏—é! üì∏");
        } else {
            await ctx.reply("–¢–∞–∫–æ–µ —Ñ–æ—Ç–æ —É–∂–µ –µ—Å—Ç—å! üëç");
        }
    }
});

// Express –¥–ª—è Railway
app.get('/', (req, res) => {
    res.send('ü§ñ –í–∏—Ç–∞–ª—è-–±–æ—Ç —Å —Ñ–æ—Ç–æ-–∫–æ–ª–ª–µ–∫—Ü–∏–µ–π —Ä–∞–±–æ—Ç–∞–µ—Ç!');
});

// üî• –í–∞–∂–Ω–æ: Graceful shutdown –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è Conflict –æ—à–∏–±–∫–∏
let isShuttingDown = false;

async function shutdown() {
    if (isShuttingDown) return;
    isShuttingDown = true;
    
    console.log("üõë –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã...");
    await saveMemory();
    await bot.stop();
    process.exit(0);
}

process.once('SIGINT', shutdown);
process.once('SIGTERM', shutdown);

// –ó–∞–≥—Ä—É–∑–∫–∞ –ø–∞–º—è—Ç–∏ –∏ –∑–∞–ø—É—Å–∫
loadMemory().then(() => {
    app.listen(PORT, () => {
        console.log(`üöÄ –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}`);
    });
    
    bot.launch().then(() => {
        console.log("ü§ñ –í–∏—Ç–∞–ª—è-–±–æ—Ç –∑–∞–ø—É—â–µ–Ω!");
    }).catch(error => {
        console.error("‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞:", error.message);
        console.log("üîÑ –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ 5 —Å–µ–∫—É–Ω–¥...");
        setTimeout(() => process.exit(1), 5000);
    });
});