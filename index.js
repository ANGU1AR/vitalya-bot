const { Telegraf } = require("telegraf");
const express = require('express');
const axios = require('axios');

// –ò–º–ø–æ—Ä—Ç –º–æ–¥—É–ª–µ–π
const { loadMemory, saveMemory, getChatMemory, updateChatMemory } = require('./memoryManager');
const { sendRandomPhoto, sendRandomVideo, sendRandomSticker, addPhotoFromUrl, addVideoFromUrl, saveMediaFromMessage } = require('./mediaManager');
const { generateMixedPhrase, analyzeMessage } = require('./aiProcessor');
const { setupRemoteControl } = require('./remoteControl');

const telegramToken = process.env.TELEGRAM_TOKEN;
const bot = new Telegraf(telegramToken);
const app = express();
const PORT = process.env.PORT || 3000;

let isBotActive = false;
let recentMessages = [];
let lastActivityTime = Date.now();
let photoTimer = null;

// üî• –ó–∞–≥—Ä—É–∑–∫–∞ –ø–∞–º—è—Ç–∏ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
async function initializeBot() {
    await loadMemory();
    console.log("üß† –ü–∞–º—è—Ç—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞!");
}

// üî• –¢–∞–π–º–µ—Ä—ã
function startTimers(chatId) {
    if (photoTimer) clearInterval(photoTimer);
    
    // –¢–∞–π–º–µ—Ä –¥–ª—è —Ñ—Ä–∞–∑
    setInterval(async () => {
        if (isBotActive && Date.now() - lastActivityTime < 300000) {
            const mixedPhrase = generateMixedPhrase(chatId);
            if (mixedPhrase && Math.random() > 0.6) {
                await bot.telegram.sendMessage(chatId, mixedPhrase);
            }
        }
    }, 180000);
    
    // –¢–∞–π–º–µ—Ä –¥–ª—è –º–µ–¥–∏–∞
    photoTimer = setInterval(async () => {
        if (isBotActive && Date.now() - lastActivityTime < 3600000) {
            if (Math.random() > 0.5) {
                const chatMemory = getChatMemory(chatId);
                const mediaType = Math.random() > 0.5 ? 'photo' : 'video';
                
                if (mediaType === 'photo' && chatMemory.photos.length > 0) {
                    await sendRandomPhoto(bot, chatId, chatMemory);
                } else if (mediaType === 'video' && chatMemory.videos.length > 0) {
                    await sendRandomVideo(bot, chatId, chatMemory);
                } else if (chatMemory.stickers.length > 0) {
                    await sendRandomSticker(bot, chatId, chatMemory);
                }
            }
        }
    }, 180000 + Math.floor(Math.random() * 3420000));
}

// üî• –ü–û–õ–ù–ê–Ø –ò–ù–¢–ï–ì–†–ê–¶–ò–Ø –° SaveAsBot
async function downloadFromSaveAsBot(url, chatId) {
    try {
        await bot.telegram.sendMessage(chatId, "–°–∫–∞—á–∏–≤–∞—é –∫–æ–Ω—Ç–µ–Ω—Ç... ‚è≥");
        
        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –∫ SaveAsBot
        await axios.post(`https://api.telegram.org/bot${telegramToken}/sendMessage`, {
            chat_id: '@SaveAsBot',
            text: url
        });
        
        // –ñ–¥–µ–º –æ—Ç–≤–µ—Ç–∞ –æ—Ç SaveAsBot
        const checkSaveAsResponse = setInterval(async () => {
            try {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç SaveAsBot
                const updates = await axios.post(`https://api.telegram.org/bot${telegramToken}/getUpdates`, {
                    offset: -10,
                    timeout: 1
                });
                
                const saveAsMessages = updates.data.result.filter(update => 
                    update.message && 
                    update.message.from.username === 'SaveAsBot' &&
                    update.message.text && 
                    (update.message.text.includes('Downloaded') || update.message.text.includes('–°–∫–∞—á–∞–Ω–æ'))
                );
                
                if (saveAsMessages.length > 0) {
                    clearInterval(checkSaveAsResponse);
                    const fileMessage = saveAsMessages[0].message;
                    
                    if (fileMessage.photo) {
                        const photo = fileMessage.photo[fileMessage.photo.length - 1];
                        const file = await bot.telegram.getFile(photo.file_id);
                        const fileUrl = `https://api.telegram.org/file/bot${telegramToken}/${file.file_path}`;
                        
                        if (addPhotoFromUrl(chatId, fileUrl)) {
                            await bot.telegram.sendPhoto(chatId, fileUrl, {
                                caption: "–ö–æ–Ω—Ç–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∫–æ–ª–ª–µ–∫—Ü–∏—é! ‚úÖ"
                            });
                        }
                    } else if (fileMessage.video) {
                        const video = fileMessage.video;
                        const file = await bot.telegram.getFile(video.file_id);
                        const fileUrl = `https://api.telegram.org/file/bot${telegramToken}/${file.file_path}`;
                        
                        if (addVideoFromUrl(chatId, fileUrl)) {
                            await bot.telegram.sendVideo(chatId, fileUrl, {
                                caption: "–ö–æ–Ω—Ç–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∫–æ–ª–ª–µ–∫—Ü–∏—é! ‚úÖ"
                            });
                        }
                    }
                }
            } catch (error) {
                console.error("–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ SaveAsBot:", error);
            }
        }, 3000);
        
        // –¢–∞–π–º–∞—É—Ç –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É
        setTimeout(() => {
            clearInterval(checkSaveAsResponse);
            bot.telegram.sendMessage(chatId, "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç üòï");
        }, 15000);
        
    } catch (error) {
        console.error("‚ùå –û—à–∏–±–∫–∞ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å SaveAsBot:", error.message);
        await bot.telegram.sendMessage(chatId, "–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ üòµ");
    }
}

// –§—Ä–∞–∑—ã –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è/–≤—ã–∫–ª—é—á–µ–Ω–∏—è
const wakeUpPhrases = ["–ì—É–¥–µ–Ω—Ç–∞–∫! üòé –í–∏—Ç–∞–ª—è –Ω–∞ —Å–≤—è–∑–∏!", "–í–∏—Ç–∞–ª—è –≤ –∑–¥–∞–Ω–∏–∏! üí™", "–ü—Ä–æ—Å–Ω—É–ª—Å—è! üöÄ –ì–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!"];
const sleepPhrases = ["–ê–π –º–ª—è! –ú–∞—Å–ª–∏–Ω—É –ø–æ–π–º–∞–ª! üòµ‚Äçüí´", "–í–∏—Ç–∞–ª—è —É—Ö–æ–¥–∏—Ç –≤ –∑–∞–∫–∞—Ç! üåÖ", "–û—Ç–∫–ª—é—á–∞—é—Å—å! üîå"];

// üî• –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π (–ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø)
bot.on("text", async (ctx) => {
    try {
        const chatId = ctx.chat.id;
        const messageText = ctx.message.text;
        const lowerText = messageText.toLowerCase();
        
        analyzeMessage(chatId, messageText);
        lastActivityTime = Date.now();
        
        // –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å SaveAsBot
        if (lowerText.startsWith('—Å–∫–∞—á–∞–π ') && isBotActive) {
            const url = messageText.slice(7).trim();
            await ctx.reply("–ü—ã—Ç–∞—é—Å—å —Å–∫–∞—á–∞—Ç—å... ‚è≥");
            await downloadFromSaveAsBot(url, chatId);
            return;
        }
        
        // –ö–æ–º–∞–Ω–¥—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        if (lowerText.includes('–≤–∏—Ç–∞–ª—è –ø—Ä–æ—Å–Ω–∏—Å—å') || lowerText.includes('–≤–∏—Ç–∞–ª—è –≤–∫–ª—é—á–∏—Å—å')) {
            if (!isBotActive) {
                isBotActive = true;
                const phrase = wakeUpPhrases[Math.floor(Math.random() * wakeUpPhrases.length)];
                await ctx.reply(phrase);
                startTimers(chatId);
            }
            return;
        }
        
        if (lowerText.includes('–≤–∏—Ç–∞–ª—è —É–π–¥–∏') || lowerText.includes('–≤–∏—Ç–∞–ª—è –≤—ã—Ä—É–±–∞–π')) {
            if (isBotActive) {
                isBotActive = false;
                const phrase = sleepPhrases[Math.floor(Math.random() * sleepPhrases.length)];
                await ctx.reply(phrase);
                if (photoTimer) clearInterval(photoTimer);
                await saveMemory();
            }
            return;
        }

        // –ö–æ–º–∞–Ω–¥–∞ UwU –¥–ª—è —Ñ–æ—Ç–æ
        if ((lowerText === 'uwu' || lowerText === '–≤–∏—Ç–∞–ª—è uwu') && isBotActive) {
            const chatMemory = getChatMemory(chatId);
            await sendRandomPhoto(bot, chatId, chatMemory);
            return;
        }

        // –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –≤–∏–¥–µ–æ
        if ((lowerText === '–≤–∏–¥–µ–æ' || lowerText === '–≤–∏—Ç–∞–ª—è –≤–∏–¥–µ–æ') && isBotActive) {
            const chatMemory = getChatMemory(chatId);
            await sendRandomVideo(bot, chatId, chatMemory);
            return;
        }

        // –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è —Å—Ç–∏–∫–µ—Ä–æ–≤
        if ((lowerText === '—Å—Ç–∏–∫–µ—Ä' || lowerText === '–≤–∏—Ç–∞–ª—è —Å—Ç–∏–∫–µ—Ä') && isBotActive) {
            const chatMemory = getChatMemory(chatId);
            await sendRandomSticker(bot, chatId, chatMemory);
            return;
        }

        // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –º–µ–¥–∏–∞ –ø–æ URL
        if (lowerText.startsWith('–¥–æ–±–∞–≤–∏—Ç—å —Ñ–æ—Ç–æ ') && isBotActive) {
            const photoUrl = messageText.slice(13).trim();
            if (addPhotoFromUrl(chatId, photoUrl)) {
                await ctx.reply("–§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –∫–æ–ª–ª–µ–∫—Ü–∏—é! üì∏");
            }
            return;
        }

        if (lowerText.startsWith('–¥–æ–±–∞–≤–∏—Ç—å –≤–∏–¥–µ–æ ') && isBotActive) {
            const videoUrl = messageText.slice(14).trim();
            if (addVideoFromUrl(chatId, videoUrl)) {
                await ctx.reply("–í–∏–¥–µ–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –∫–æ–ª–ª–µ–∫—Ü–∏—é! üé•");
            }
            return;
        }

        // –û—Ç–≤–µ—Ç –Ω–∞ –æ–±—Ä–∞—â–µ–Ω–∏–µ
        if (isBotActive && (lowerText.startsWith('–≤–∏—Ç–∞–ª—è') || Math.random() > 0.7)) {
            const userMessage = lowerText.startsWith('–≤–∏—Ç–∞–ª—è') ? messageText.slice(7).trim() : messageText;
            
            if (userMessage) {
                await ctx.sendChatAction('typing');
                const mixedPhrase = generateMixedPhrase(chatId);
                const response = mixedPhrase || "–ß—Ç–æ-—Ç–æ —è —Å–µ–≥–æ–¥–Ω—è –Ω–µ –≤ —Ñ–æ—Ä–º–µ... ü§î";
                await ctx.reply(response);
            }
        }
    } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è:", error.message);
    }
});

// üî• –û–±—Ä–∞–±–æ—Ç–∫–∞ –º–µ–¥–∏–∞-—Å–æ–æ–±—â–µ–Ω–∏–π (–ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø)
bot.on(["photo", "video", "sticker"], async (ctx) => {
    try {
        if (isBotActive) {
            const chatId = ctx.chat.id;
            const savedUrl = await saveMediaFromMessage(chatId, ctx);
            if (savedUrl) {
                await ctx.reply("–ú–µ–¥–∏–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ –∫–æ–ª–ª–µ–∫—Ü–∏—é! ‚úÖ");
            }
        }
    } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –º–µ–¥–∏–∞:", error.message);
    }
});

// üî• –û–±—Ä–∞–±–æ—Ç–∫–∞ –º–µ–¥–∏–∞-—Å–æ–æ–±—â–µ–Ω–∏–π
bot.on(["photo", "video", "sticker"], async (ctx) => {
    if (isBotActive) {
        const chatId = ctx.chat.id;
        const savedUrl = await saveMediaFromMessage(chatId, ctx);
        if (savedUrl) {
            await ctx.reply("–ú–µ–¥–∏–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ –∫–æ–ª–ª–µ–∫—Ü–∏—é! ‚úÖ");
        }
    }
});

// Express –¥–ª—è Railway
app.get('/', (req, res) => {
    res.send('ü§ñ –í–∏—Ç–∞–ª—è-–±–æ—Ç —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –ø–∞–º—è—Ç—å—é —Ä–∞–±–æ—Ç–∞–µ—Ç!');
});

// üî• –ó–∞–ø—É—Å–∫
initializeBot().then(() => {
    app.listen(PORT, () => {
        console.log(`üöÄ –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}`);
    });
    
    setupRemoteControl(bot);
    
    bot.launch().then(() => {
        console.log("ü§ñ –í–∏—Ç–∞–ª—è-–±–æ—Ç –∑–∞–ø—É—â–µ–Ω!");
    });
});

// Graceful shutdown
process.once('SIGINT', async () => {
    await saveMemory();
    bot.stop('SIGINT');
});

process.once('SIGTERM', async () => {
    await saveMemory();
    bot.stop('SIGTERM');
});